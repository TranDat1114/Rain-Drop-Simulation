<!DOCTYPE html>
<html lang="en">
<!doctype html>
<html lang="vi">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Isometric Rain & Ripples</title>
        <style>
            html,body{height:100%;margin:0;background:#0b1220;color:#dfeeff;font-family:system-ui,Segoe UI,Roboto,Arial}
            canvas{display:block;width:100%;height:100%}
            #overlay{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.35);backdrop-filter:blur(4px);padding:8px 10px;border-radius:8px;font-size:13px}
            a{color:#9fd3ff}
        </style>
    </head>
    <body>
        <canvas id="c"></canvas>
        <div id="overlay">
            <div>Click/tap to spawn heavy rain. Press Space to toggle rain.</div>
            <div style="margin-top:6px">Drops/sec: <span id="rate">120</span> · Ripples: <span id="count">0</span></div>
        </div>

        <script>
        // Isometric rain + ripple simulation on HTML Canvas
        // - Projection: isometric with 30° angle (cos=0.866, sin=0.5)
        // - Plain JS, no external libs

        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d', { alpha: false });
        const overlayRate = document.getElementById('rate');
        const overlayCount = document.getElementById('count');

        let DPR = Math.max(1, window.devicePixelRatio || 1);
        function resize(){
            DPR = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(canvas.clientWidth * DPR);
            canvas.height = Math.floor(canvas.clientHeight * DPR);
            ctx.setTransform(DPR,0,0,DPR,0,0);
        }
        window.addEventListener('resize', resize);
        resize();

        // Isometric projection constants
        const ISO_ANGLE = Math.PI/6; // 30deg
        const COS = Math.cos(ISO_ANGLE); // ~0.866
        const SIN = Math.sin(ISO_ANGLE); // ~0.5

        // World plane size (in world units). We'll center the plane under the camera.
        const PLANE_SIZE = 1400; // world units along each horizontal axis
        const CENTER_X = 0;
        const CENTER_Y = 0;

        function project(pos){
            // pos: {x,y,z} in world units. Return screen {x,y}
            const sx = (pos.x - pos.y) * COS;
            const sy = (pos.x + pos.y) * SIN - pos.z;
            // translate to canvas center
            return { x: sx + canvas.clientWidth/2, y: sy + canvas.clientHeight*0.45 };
        }

        // Entities
        class Drop {
            constructor(){
                this.x = (Math.random()*2-1) * PLANE_SIZE/2;
                this.y = (Math.random()*2-1) * PLANE_SIZE/2;
                this.z = 300 + Math.random()*200; // start height
                this.vz = 600 + Math.random()*300; // falling speed units/sec
                this.alive = true;
            }
            update(dt){
                this.z -= this.vz * dt;
                if(this.z <= 0){
                    this.alive = false;
                    spawnRipple(this.x, this.y);
                    spawnSplash(this.x, this.y);
                }
            }
            draw(ctx){
                const p = project(this);
                const alpha = Math.min(1, Math.max(0, this.z/400));
                ctx.fillStyle = `rgba(180,220,255,${0.9*alpha})`;
                ctx.beginPath();
                ctx.ellipse(p.x, p.y, 1.5 + (this.z/200), 3 + (this.z/150), 0, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Ripple {
            constructor(x,y){
                this.x = x; this.y = y; this.age = 0; this.life = 1.8 + Math.random()*0.8; // seconds
                this.speed = 220 + Math.random()*80; // world units/sec
                this.maxR = this.speed * this.life;
                this.rings = 2 + Math.floor(Math.random()*2);
            }
            update(dt){ this.age += dt; }
            draw(ctx){
                const t = this.age / this.life;
                if(t>1) return;
                const baseRadius = this.speed * this.age;
                const fade = Math.pow(1 - t, 2);
                const p = project({x:this.x,y:this.y,z:0});

                ctx.save();
                // isometric foreshortening: vertical radius shorter
                const ry = 0.5;
                for(let i=0;i<this.rings;i++){
                    const ringOffset = i * 18;
                    const radius = baseRadius - ringOffset;
                    if(radius <= 0) continue;
                    const alpha = Math.max(0, 0.9 * fade * (1 - (radius/this.maxR)));
                    ctx.strokeStyle = `rgba(220,245,255,${alpha.toFixed(3)})`;
                    ctx.lineWidth = 2 * (0.6 - 0.4*i/this.rings) * (1 - t*0.6);
                    ctx.beginPath();
                    ctx.ellipse(p.x, p.y, radius, radius*ry, 0, 0, Math.PI*2);
                    ctx.stroke();
                }
                ctx.restore();
            }
            get dead(){ return this.age > this.life; }
        }

        // small splash particles
        class Splash {
            constructor(x,y){
                this.x = x; this.y = y; this.v = 120 + Math.random()*120; this.dir = (Math.random()*Math.PI*2);
                this.age = 0; this.life = 0.6 + Math.random()*0.6; this.z = 0; this.vz = 120 + Math.random()*160;
            }
            update(dt){
                this.age += dt;
                this.x += Math.cos(this.dir) * this.v * dt;
                this.y += Math.sin(this.dir) * this.v * dt;
                this.z += this.vz * dt - 350 * dt * this.age; // simple gravity-ish
            }
            draw(ctx){
                const t = this.age/this.life; if(t>1) return;
                const p = project({x:this.x,y:this.y,z: this.z});
                ctx.fillStyle = `rgba(200,230,255,${Math.max(0,1-t).toFixed(3)})`;
                ctx.beginPath(); ctx.ellipse(p.x,p.y,1.2,2.2,0,0,Math.PI*2); ctx.fill();
            }
            get dead(){ return this.age > this.life; }
        }

        const drops = [];
        const ripples = [];
        const splashes = [];

        function spawnDrop(){ drops.push(new Drop()); }
        function spawnRipple(x,y){ ripples.push(new Ripple(x,y)); }
        function spawnSplash(x,y){ for(let i=0;i<4+Math.floor(Math.random()*6);i++) splashes.push(new Splash(x,y)); }

        // Rain controller
        let rainOn = true;
        let dropsPerSec = 120; // default
        overlayRate.textContent = dropsPerSec;

        let dropAccumulator = 0;

        // Main loop
        let last = performance.now();
        function step(now){
            const dt = Math.min(0.04, (now - last)/1000);
            last = now;

            // spawn
            if(rainOn){
                dropAccumulator += dropsPerSec * dt;
                while(dropAccumulator >= 1){ spawnDrop(); dropAccumulator -= 1; }
            }

            // update
            for(let i=drops.length-1;i>=0;i--){ drops[i].update(dt); if(!drops[i].alive) drops.splice(i,1); }
            for(let i=ripples.length-1;i>=0;i--){ ripples[i].update(dt); if(ripples[i].dead) ripples.splice(i,1); }
            for(let i=splashes.length-1;i>=0;i--){ splashes[i].update(dt); if(splashes[i].dead) splashes.splice(i,1); }

            draw();
            requestAnimationFrame(step);
        }

        function draw(){
            // background
            const w = canvas.clientWidth, h = canvas.clientHeight;
            // sky gradient
            const g = ctx.createLinearGradient(0,0,0,h*0.8);
            g.addColorStop(0,'#041022'); g.addColorStop(1,'#072035');
            ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

            // subtle horizon light
            const hx = ctx.createLinearGradient(0,h*0.35,0,h);
            hx.addColorStop(0,'rgba(120,170,200,0.06)'); hx.addColorStop(1,'rgba(10,20,30,0.02)');
            ctx.fillStyle = hx; ctx.fillRect(0,0,w,h);

            // Water plane base (isometric diamond)
            const corners = [
                project({x:-PLANE_SIZE/2,y:-PLANE_SIZE/2,z:0}),
                project({x: PLANE_SIZE/2,y:-PLANE_SIZE/2,z:0}),
                project({x: PLANE_SIZE/2,y: PLANE_SIZE/2,z:0}),
                project({x:-PLANE_SIZE/2,y: PLANE_SIZE/2,z:0})
            ];
            // base gradient
            const poly = new Path2D(); poly.moveTo(corners[0].x,corners[0].y);
            for(let i=1;i<corners.length;i++) poly.lineTo(corners[i].x,corners[i].y);
            poly.closePath();
            const mg = ctx.createLinearGradient(0,corners[0].y,0,corners[2].y);
            mg.addColorStop(0,'#0b2a3b'); mg.addColorStop(1,'#052033');
            ctx.fillStyle = mg; ctx.fill(poly);

            // thin grid for perspective hints
            ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1;
            const GRID_STEP = 80;
            for(let gx=-PLANE_SIZE/2; gx<=PLANE_SIZE/2; gx+=GRID_STEP){
                const p1 = project({x:gx,y:-PLANE_SIZE/2,z:0});
                const p2 = project({x:gx,y: PLANE_SIZE/2,z:0});
                ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
            }
            for(let gy=-PLANE_SIZE/2; gy<=PLANE_SIZE/2; gy+=GRID_STEP){
                const p1 = project({x:-PLANE_SIZE/2,y:gy,z:0});
                const p2 = project({x: PLANE_SIZE/2,y:gy,z:0});
                ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
            }

            // draw ripples under (below splashes so they appear on surface)
            ctx.save(); ctx.globalCompositeOperation = 'lighter';
            for(const r of ripples) r.draw(ctx);
            ctx.restore();

            // draw splashes and drops on top
            for(const s of splashes) s.draw(ctx);
            for(const d of drops) d.draw(ctx);

            overlayCount.textContent = ripples.length;
        }

        // interactions
        window.addEventListener('click', (e)=>{
            // spawn a cluster of drops around click (map screen->world approx inverse)
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left - canvas.clientWidth/2;
            const sy = e.clientY - rect.top - canvas.clientHeight*0.45;
            // invert isometric roughly for ground point
            const wx = (sx/COS + sy/SIN)/2;
            const wy = (sy/SIN - sx/COS)/2;
            for(let i=0;i<60;i++){ const d = new Drop(); d.x = wx + (Math.random()-0.5)*120; d.y = wy + (Math.random()-0.5)*120; d.z = 200 + Math.random()*180; drops.push(d); }
        });

        window.addEventListener('keydown', (e)=>{
            if(e.code === 'Space'){ rainOn = !rainOn; }
        });

        // small UI controls: mouse wheel changes rate
        window.addEventListener('wheel', (ev)=>{
            const delta = Math.sign(ev.deltaY);
            dropsPerSec = Math.max(0, dropsPerSec - delta*12);
            overlayRate.textContent = dropsPerSec;
        }, {passive:true});

        // initial seeding
        for(let i=0;i<50;i++) spawnDrop();

        requestAnimationFrame(step);
        </script>
    </body>
</html>
</html>